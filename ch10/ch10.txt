1.struct {                            struct {
    int a;                                    int a;
    char b;                                   char b;
    float c;                                  float c;
  } y[20], *z;                        } x;
  以上连个声明虽然成员列表完全相同，但是y，z和x属于不同的类型，所以，
  z = &x;是非法的。
2.为了使y，z和x属于同一个类型，可以使用一下两种方法进行声明：
  1)typedef struct {
    int a;
    char b;
    float c;
  } Simple;
  Simple x;
  Simple y[20], *z;
  2)struct Simple {
    int a;
    char b;
    float c;
  };
  struct Simple x;
  strcut Simple y[20], *z;
3.typedef struct {
  int a;
  SELF_REF3* b;
  int c;
} SELF_REF3;错误，类型名直到末尾才定义，在声明的内部尚未定义。
可以用一个标签来解决这个问题：
typedef struct SELF_REF3_TAG {
  int a;
  struct SELF_REF3_TAG *b;
  int c;
} SELF_REF3;
4.不完整声明
  struct B;
  struct A{
    struct B *partner;
  };
  struct B{
   struct A *partner;
  };
5.结构变量可以用花括号来初始化变量，这些值的类型必须符合初始化的成员，如果初始化
列表的值不够，剩余的值按照默认值初始化。
6.在实现结构存储的边界的对齐时，可能会浪费一部分空间。根据边界对齐要求降序排列
成员可最大限度的减少结构中浪费的空间。
7.sizeof返回的值包含结构中浪费的空间。
8.宏offsetof( type， member )表示指定成员开始存储的位置距离结构开始存储位置
几个字节。
9.向一个函数传递结构指针效率更高（除了结构特别小的情况下），通常添加一个const
防止函数修改指针指向的内容。
10.位段不可移植。
11.一个联合的素有成员存储在一个内存位置，联合的长度就是最长的成员的长度。在实现变体记录的时候特别有用，可以通过
一个枚举类型来标明属于哪种变体。联合的初始化必须是第一个成员类型。
